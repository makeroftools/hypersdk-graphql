//! Raw API types for Hyperliquid exchange actions.
//!
//! This module contains the core action types and request/response structures
//! used for interacting with the Hyperliquid exchange API. These types handle
//! signing, serialization, and API communication.

use alloy::{
    dyn_abi::TypedData,
    primitives::{Address, B256},
    signers::{Signer, SignerSync, k256::ecdsa::RecoveryId},
};
use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};

use crate::hypercore::{
    Chain,
    types::{
        BatchCancel, BatchCancelCloid, BatchModify, BatchOrder, CORE_MAINNET_EIP712_DOMAIN,
        OrderResponseStatus, ScheduleCancel, Signature,
    },
    utils::{self, get_typed_data},
};

use super::solidity;

/// Request for an action.
///
/// Contains the action, a nonce, signature, optional vault address, and optional expiry.
#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct ActionRequest {
    /// Action.
    pub action: Action,
    /// Nonce of the message.
    pub nonce: u64,
    /// Signature
    pub signature: Signature,
    /// Trading on behalf of
    pub vault_address: Option<Address>,
    /// Timestamp in milliseconds
    pub expires_after: Option<u64>,
}

/// An action that requires signing.
///
/// Represents a request to the exchange that must be signed by the user.
#[derive(Debug, Clone, Serialize, Deserialize, derive_more::From)]
#[serde(tag = "type")]
#[serde(rename_all = "camelCase")]
pub enum Action {
    /// Order insertion.
    Order(BatchOrder),
    /// Order modification.
    BatchModify(BatchModify),
    /// Order cancellation by oid.
    Cancel(BatchCancel),
    /// Order cancellation by cloid.
    CancelByCloid(BatchCancelCloid),
    /// Schedule cancellation of all orders.
    ScheduleCancel(ScheduleCancel),
    /// Core USDC transfer.
    UsdSend(UsdSendAction),
    /// Send asset.
    SendAsset(SendAssetAction),
    /// Spot send.
    SpotSend(SpotSendAction),
    /// EVM user modify.
    EvmUserModify {
        using_big_blocks: bool,
    },
    ApproveAgent(ApproveAgent),
    /// Convert to multi-signature user.
    ConvertToMultiSigUser(ConvertToMultiSigUser),
    /// Multi-sig action.
    MultiSig(MultiSigAction),
    /// Invalidate a request.
    Noop,
}

impl Action {
    /// Hash the action for signing.
    ///
    /// The hash is generated by serializing the action to MessagePack, appending the nonce,
    /// optional vault address, and optional expiry, then Keccak256 hashing.
    #[inline]
    pub fn hash(
        &self,
        nonce: u64,
        maybe_vault_address: Option<Address>,
        maybe_expires_after: Option<u64>,
    ) -> Result<B256, rmp_serde::encode::Error> {
        utils::rmp_hash(self, nonce, maybe_vault_address, maybe_expires_after)
    }
}

impl Action {
    /// Returns the typed data for multisig signing, if applicable.
    ///
    /// Only EIP-712 typed data actions (UsdSend, SpotSend, SendAsset) support multisig typed data.
    /// All other actions (orders, cancels, modifications) return None and use RMP hash signing.
    pub fn typed_data_multisig(
        &self,
        multi_sig_user: Address,
        lead: Address,
        chain: Chain,
    ) -> Option<TypedData> {
        let multi_sig = Some((multi_sig_user, lead));

        match self {
            Action::UsdSend(inner) => Some(utils::get_typed_data::<solidity::multisig::UsdSend>(
                inner, chain, multi_sig,
            )),
            Action::SpotSend(inner) => Some(utils::get_typed_data::<solidity::multisig::SpotSend>(
                inner, chain, multi_sig,
            )),
            Action::SendAsset(inner) => Some(
                utils::get_typed_data::<solidity::multisig::SendAsset>(inner, chain, multi_sig),
            ),
            Action::ConvertToMultiSigUser(inner) => Some(utils::get_typed_data::<
                solidity::multisig::ConvertToMultiSigUser,
            >(inner, chain, multi_sig)),
            // All other actions use RMP signing
            _ => None,
        }
    }
}

/// API response wrapper.
///
/// The `Ok` variant contains a successful response, while `Err` holds an error message.
#[derive(Debug, Deserialize)]
#[serde(tag = "status", content = "response")]
#[serde(rename_all = "camelCase")]
pub enum Response {
    Ok(OkResponse),
    Err(String),
}

/// Successful API response data.
///
/// Currently supports order responses and a default placeholder.
#[derive(Debug, Deserialize)]
#[serde(tag = "type", content = "data")]
#[serde(rename_all = "camelCase")]
pub enum OkResponse {
    Order { statuses: Vec<OrderResponseStatus> },
    Cancel { statuses: Vec<OrderResponseStatus> },
    // should be ok?
    Default,
}

impl Action {
    /// Signs this action synchronously and returns an `ActionRequest`.
    ///
    /// Computes the prehash using the action's signing method (RMP+Agent for orders/cancels,
    /// EIP-712 for transfers), then signs it with the provided signer.
    pub fn sign_sync<S: SignerSync>(
        self,
        signer: &S,
        nonce: u64,
        maybe_vault_address: Option<Address>,
        maybe_expires_after: Option<DateTime<Utc>>,
        chain: Chain,
    ) -> anyhow::Result<ActionRequest> {
        let expires_after = maybe_expires_after.map(|after| after.timestamp_millis() as u64);

        // Sign based on action type
        let alloy_sig = match &self {
            // RMP-based actions - use Agent wrapper
            Action::Order(_)
            | Action::BatchModify(_)
            | Action::Cancel(_)
            | Action::CancelByCloid(_)
            | Action::ScheduleCancel(_)
            | Action::EvmUserModify { .. }
            | Action::Noop => {
                let connection_id = self.hash(nonce, maybe_vault_address, expires_after)?;
                let agent = solidity::Agent {
                    source: if chain.is_mainnet() { "a" } else { "b" }.to_string(),
                    connectionId: connection_id,
                };
                signer.sign_typed_data_sync(&agent, &CORE_MAINNET_EIP712_DOMAIN)?
            }
            // EIP-712 typed data actions
            Action::UsdSend(inner) => {
                let typed_data = get_typed_data::<solidity::UsdSend>(&inner, chain, None);
                signer.sign_dynamic_typed_data_sync(&typed_data)?
            }
            Action::SendAsset(inner) => {
                let typed_data = get_typed_data::<solidity::SendAsset>(&inner, chain, None);
                signer.sign_dynamic_typed_data_sync(&typed_data)?
            }
            Action::SpotSend(inner) => {
                let typed_data = get_typed_data::<solidity::SpotSend>(&inner, chain, None);
                signer.sign_dynamic_typed_data_sync(&typed_data)?
            }
            Action::ApproveAgent(inner) => {
                let typed_data = get_typed_data::<solidity::ApproveAgent>(&inner, chain, None);
                signer.sign_dynamic_typed_data_sync(&typed_data)?
            }
            Action::ConvertToMultiSigUser(inner) => {
                let typed_data =
                    get_typed_data::<solidity::ConvertToMultiSigUser>(&inner, chain, None);
                signer.sign_dynamic_typed_data_sync(&typed_data)?
            }
            // MultiSig - wrap in envelope
            Action::MultiSig(inner) => {
                let multsig_hash =
                    utils::rmp_hash(&inner, nonce, maybe_vault_address, expires_after)?;

                #[derive(Serialize)]
                #[serde(rename_all = "camelCase")]
                struct Envelope {
                    hyperliquid_chain: String,
                    multi_sig_action_hash: String,
                    nonce: u64,
                }

                let envelope = Envelope {
                    hyperliquid_chain: chain.to_string(),
                    multi_sig_action_hash: multsig_hash.to_string(),
                    nonce,
                };

                let typed_data = get_typed_data::<solidity::SendMultiSig>(&envelope, chain, None);
                signer.sign_dynamic_typed_data_sync(&typed_data)?
            }
        };

        let signature: Signature = alloy_sig.into();

        // Build the action request
        Ok(ActionRequest {
            signature,
            action: self,
            nonce,
            vault_address: maybe_vault_address,
            expires_after,
        })
    }

    /// Signs this action asynchronously and returns an `ActionRequest`.
    ///
    /// Computes the prehash using the action's signing method (RMP+Agent for orders/cancels,
    /// EIP-712 for transfers), then signs it with the provided signer.
    pub async fn sign<S: Signer + Send + Sync>(
        self,
        signer: &S,
        nonce: u64,
        maybe_vault_address: Option<Address>,
        maybe_expires_after: Option<DateTime<Utc>>,
        chain: Chain,
    ) -> anyhow::Result<ActionRequest> {
        let expires_after = maybe_expires_after.map(|after| after.timestamp_millis() as u64);

        // Sign based on action type
        let alloy_sig = match &self {
            // RMP-based actions - use Agent wrapper
            Action::Order(_)
            | Action::BatchModify(_)
            | Action::Cancel(_)
            | Action::CancelByCloid(_)
            | Action::ScheduleCancel(_)
            | Action::EvmUserModify { .. }
            | Action::Noop => {
                let connection_id = self.hash(nonce, maybe_vault_address, expires_after)?;
                let agent = solidity::Agent {
                    source: if chain.is_mainnet() { "a" } else { "b" }.to_string(),
                    connectionId: connection_id,
                };
                signer
                    .sign_typed_data(&agent, &CORE_MAINNET_EIP712_DOMAIN)
                    .await?
            }
            // EIP-712 typed data actions
            Action::UsdSend(inner) => {
                let typed_data = get_typed_data::<solidity::UsdSend>(&inner, chain, None);
                signer.sign_dynamic_typed_data(&typed_data).await?
            }
            Action::SendAsset(inner) => {
                let typed_data = get_typed_data::<solidity::SendAsset>(&inner, chain, None);
                signer.sign_dynamic_typed_data(&typed_data).await?
            }
            Action::SpotSend(inner) => {
                let typed_data = get_typed_data::<solidity::SpotSend>(&inner, chain, None);
                signer.sign_dynamic_typed_data(&typed_data).await?
            }
            Action::ApproveAgent(inner) => {
                let typed_data = get_typed_data::<solidity::ApproveAgent>(&inner, chain, None);
                signer.sign_dynamic_typed_data(&typed_data).await?
            }
            Action::ConvertToMultiSigUser(inner) => {
                let typed_data =
                    get_typed_data::<solidity::ConvertToMultiSigUser>(&inner, chain, None);
                signer.sign_dynamic_typed_data(&typed_data).await?
            }
            // MultiSig - wrap in envelope
            Action::MultiSig(inner) => {
                let multsig_hash =
                    utils::rmp_hash(&inner, nonce, maybe_vault_address, expires_after)?;

                #[derive(Serialize)]
                #[serde(rename_all = "camelCase")]
                struct Envelope {
                    hyperliquid_chain: String,
                    multi_sig_action_hash: String,
                    nonce: u64,
                }

                let envelope = Envelope {
                    hyperliquid_chain: chain.to_string(),
                    multi_sig_action_hash: multsig_hash.to_string(),
                    nonce,
                };

                let typed_data = get_typed_data::<solidity::SendMultiSig>(&envelope, chain, None);
                signer.sign_dynamic_typed_data(&typed_data).await?
            }
        };

        let signature: Signature = alloy_sig.into();

        // Build the action request
        Ok(ActionRequest {
            signature,
            action: self,
            nonce,
            vault_address: maybe_vault_address,
            expires_after,
        })
    }

    /// Computes the hash to be signed for this action.
    ///
    /// Uses RMP serialization with Agent wrapper for orders/cancels, or EIP-712 typed data
    /// for transfers. Returns the final hash ready for signing.
    pub fn prehash(
        &self,
        nonce: u64,
        maybe_vault_address: Option<Address>,
        maybe_expires_after: Option<DateTime<Utc>>,
        chain: Chain,
    ) -> anyhow::Result<B256> {
        match self {
            // RMP-based actions - hash and wrap in Agent struct
            Action::Order(_)
            | Action::BatchModify(_)
            | Action::Cancel(_)
            | Action::CancelByCloid(_)
            | Action::ScheduleCancel(_)
            | Action::EvmUserModify { .. }
            | Action::Noop => {
                let expires_after =
                    maybe_expires_after.map(|after| after.timestamp_millis() as u64);
                let connection_id = self
                    .hash(nonce, maybe_vault_address, expires_after)
                    .map_err(|e| anyhow::anyhow!("Failed to hash action: {}", e))?;
                Ok(crate::hypercore::signing::agent_signing_hash(
                    chain,
                    connection_id,
                ))
            }
            // EIP-712 typed data actions - get signing hash directly
            Action::UsdSend(inner) => {
                let typed_data = get_typed_data::<solidity::UsdSend>(&inner, chain, None);
                Ok(typed_data.eip712_signing_hash()?)
            }
            Action::SendAsset(inner) => {
                let typed_data = get_typed_data::<solidity::SendAsset>(&inner, chain, None);
                Ok(typed_data.eip712_signing_hash()?)
            }
            Action::SpotSend(inner) => {
                let typed_data = get_typed_data::<solidity::SpotSend>(&inner, chain, None);
                Ok(typed_data.eip712_signing_hash()?)
            }
            Action::ApproveAgent(inner) => {
                let typed_data = get_typed_data::<solidity::ApproveAgent>(&inner, chain, None);
                Ok(typed_data.eip712_signing_hash()?)
            }
            Action::ConvertToMultiSigUser(inner) => {
                let typed_data =
                    get_typed_data::<solidity::ConvertToMultiSigUser>(&inner, chain, None);
                Ok(typed_data.eip712_signing_hash()?)
            }
            // MultiSig - hash the entire multisig action and wrap in envelope
            Action::MultiSig(inner) => {
                let expires_after =
                    maybe_expires_after.map(|after| after.timestamp_millis() as u64);
                let multsig_hash =
                    utils::rmp_hash(&inner, nonce, maybe_vault_address, expires_after)?;

                #[derive(Serialize)]
                #[serde(rename_all = "camelCase")]
                struct Envelope {
                    hyperliquid_chain: String,
                    multi_sig_action_hash: String,
                    nonce: u64,
                }

                let envelope = Envelope {
                    hyperliquid_chain: chain.to_string(),
                    multi_sig_action_hash: multsig_hash.to_string(),
                    nonce,
                };

                let typed_data = get_typed_data::<solidity::SendMultiSig>(&envelope, chain, None);
                Ok(typed_data.eip712_signing_hash()?)
            }
        }
    }

    /// Recovers the signer's address from a signature.
    ///
    /// Computes the prehash for this action and recovers the Ethereum address that
    /// created the signature using ECDSA recovery.
    pub fn recover(
        &self,
        signature: &Signature,
        nonce: u64,
        maybe_vault_address: Option<Address>,
        maybe_expires_after: Option<DateTime<Utc>>,
        chain: Chain,
    ) -> anyhow::Result<Address> {
        let recid = RecoveryId::from_byte(signature.v as u8 - 27_u8)
            .ok_or_else(|| anyhow::anyhow!("unable to convert recovery_id: {}", signature.v))?;
        let sig = alloy::signers::Signature::new(signature.r, signature.s, recid.is_y_odd());
        let prehash = self.prehash(nonce, maybe_vault_address, maybe_expires_after, chain)?;
        Ok(sig.recover_address_from_prehash(&prehash)?)
    }
}

/// Send USDC from the perpetual balance.
///
/// This action transfers USDC from your perpetual trading balance to another address.
/// The transfer happens on the Hyperliquid L1 and requires EIP-712 signature.
///
/// # Fields
///
/// - `signature_chain_id`: The chain ID for signature verification (use [`crate::hypercore::ARBITRUM_MAINNET_CHAIN_ID`] or [`crate::hypercore::ARBITRUM_TESTNET_CHAIN_ID`])
/// - `hyperliquid_chain`: Whether this is mainnet or testnet
/// - `destination`: The recipient's address
/// - `amount`: Amount of USDC to send (in USDC, not wei)
/// - `time`: Timestamp in milliseconds (should match the nonce)
///
/// # Example
///
/// ```rust,ignore
/// use hypersdk::hypercore::types::raw::UsdSendAction;
/// use rust_decimal::dec;
///
/// let send = UsdSendAction {
///     signature_chain_id: ARBITRUM_MAINNET_CHAIN_ID,
///     hyperliquid_chain: Chain::Mainnet,
///     destination: "0x1234...".parse()?,
///     amount: dec!(100), // 100 USDC
///     time: chrono::Utc::now().timestamp_millis() as u64,
/// };
/// ```
///
/// <https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#core-usdc-transfer>
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct UsdSendAction {
    /// Signature chain ID.
    ///
    /// For arbitrum use [`crate::hypercore::ARBITRUM_MAINNET_CHAIN_ID`] or [`crate::hypercore::ARBITRUM_TESTNET_CHAIN_ID`].
    pub signature_chain_id: String,
    /// The chain this action is being executed on.
    pub hyperliquid_chain: Chain,
    /// The destination address.
    #[serde(
        serialize_with = "crate::hypercore::utils::serialize_address_as_hex",
        deserialize_with = "crate::hypercore::utils::deserialize_address_from_hex"
    )]
    pub destination: Address,
    /// The amount.
    #[serde(with = "rust_decimal::serde::str")]
    pub amount: Decimal,
    /// Current time, should match the nonce
    pub time: u64,
}

/// Send spot tokens to another address.
///
/// This action transfers spot tokens (like PURR, HYPE, etc.) from your spot balance
/// to another address. The transfer happens on the Hyperliquid L1 and requires EIP-712 signature.
///
/// # Fields
///
/// - `signature_chain_id`: The chain ID for signature verification (use [`crate::hypercore::ARBITRUM_MAINNET_CHAIN_ID`] or [`crate::hypercore::ARBITRUM_TESTNET_CHAIN_ID`])
/// - `hyperliquid_chain`: Whether this is mainnet or testnet
/// - `destination`: The recipient's address
/// - `token`: The spot token to send (wrapped in `SendToken`)
/// - `amount`: Amount to send (in token's native units)
/// - `time`: Timestamp in milliseconds (should match the nonce)
///
/// # Example
///
/// ```rust,ignore
/// use hypersdk::hypercore::types::raw::{SpotSendAction, SendToken};
/// use rust_decimal::dec;
///
/// let send = SpotSendAction {
///     signature_chain_id: ARBITRUM_MAINNET_CHAIN_ID,
///     hyperliquid_chain: Chain::Mainnet,
///     destination: "0x1234...".parse()?,
///     token: SendToken(purr_token),
///     amount: dec!(1000),
///     time: chrono::Utc::now().timestamp_millis() as u64,
/// };
/// ```
///
/// <https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#core-spot-transfer>
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct SpotSendAction {
    /// Signature chain ID.
    ///
    /// For arbitrum use [`crate::hypercore::ARBITRUM_MAINNET_CHAIN_ID`] or [`crate::hypercore::ARBITRUM_TESTNET_CHAIN_ID`].
    pub signature_chain_id: String,
    /// The chain this action is being executed on.
    pub hyperliquid_chain: Chain,
    /// The destination address.
    #[serde(
        serialize_with = "crate::hypercore::utils::serialize_address_as_hex",
        deserialize_with = "crate::hypercore::utils::deserialize_address_from_hex"
    )]
    pub destination: Address,
    /// Token
    pub token: String,
    /// The amount.
    #[serde(with = "rust_decimal::serde::str")]
    pub amount: Decimal,
    /// Current time, should match the nonce
    pub time: u64,
}

/// Send asset.
///
/// <https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#send-asset>
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct SendAssetAction {
    /// Signature chain ID.
    ///
    /// For arbitrum use [`crate::hypercore::ARBITRUM_MAINNET_CHAIN_ID`] or [`crate::hypercore::ARBITRUM_TESTNET_CHAIN_ID`].
    pub signature_chain_id: String,
    /// The chain this action is being executed on.
    pub hyperliquid_chain: Chain,
    /// The destination address.
    #[serde(
        serialize_with = "crate::hypercore::utils::serialize_address_as_hex",
        deserialize_with = "crate::hypercore::utils::deserialize_address_from_hex"
    )]
    pub destination: Address,
    /// Source DEX, can be empty
    pub source_dex: String,
    /// Destiation DEX, can be empty
    pub destination_dex: String,
    /// Token
    pub token: String,
    /// The amount.
    #[serde(with = "rust_decimal::serde::str")]
    pub amount: Decimal,
    /// From subaccount, can be empty
    pub from_sub_account: String,
    /// Request nonce
    pub nonce: u64,
}

/// Approve agent
///
/// <https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#approve-an-api-wallet>
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct ApproveAgent {
    /// Signature chain ID.
    ///
    /// For arbitrum use [`crate::hypercore::ARBITRUM_MAINNET_CHAIN_ID`] or [`crate::hypercore::ARBITRUM_TESTNET_CHAIN_ID`].
    pub signature_chain_id: String,
    /// The chain this action is being executed on.
    pub hyperliquid_chain: Chain,
    /// The agent address.
    #[serde(
        serialize_with = "crate::hypercore::utils::serialize_address_as_hex",
        deserialize_with = "crate::hypercore::utils::deserialize_address_from_hex"
    )]
    pub agent_address: Address,
    /// Agent name.
    ///
    /// An account can have 1 unnamed approved wallet,
    /// up to 3 named ones, and 2 named agents per subaccount.
    pub agent_name: Option<String>,
    /// Request nonce
    pub nonce: u64,
}

/// Multisig configuration for converting an account to multisig.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
#[serde(rename_all = "camelCase")]
pub struct SignersConfig {
    /// Addresses authorized to sign for this multisig account
    pub authorized_users: Vec<Address>,
    /// Minimum number of signatures required (e.g., 2 for 2-of-3)
    pub threshold: usize,
}

/// Convert account to multi-signature user.
///
/// Converts a regular account to a multisig account by specifying authorized signers
/// and the required signature threshold.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct ConvertToMultiSigUser {
    /// Signature chain ID.
    ///
    /// For arbitrum use [`crate::hypercore::ARBITRUM_MAINNET_CHAIN_ID`] or [`crate::hypercore::ARBITRUM_TESTNET_CHAIN_ID`].
    pub signature_chain_id: String,
    /// The chain this action is being executed on.
    pub hyperliquid_chain: Chain,
    /// Signers configuration (authorized users and threshold) as JSON string
    #[serde(serialize_with = "crate::hypercore::utils::serialize_signers_as_json")]
    #[serde(deserialize_with = "crate::hypercore::utils::deserialize_signers_as_json")]
    pub signers: SignersConfig,
    /// Request nonce
    pub nonce: u64,
}

/// Multi-signature action payload.
///
/// Contains the multisig user address, outer signer, and the inner action to execute.
#[derive(Clone, Serialize, Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct MultiSigPayload {
    /// The multisig account address
    pub multi_sig_user: String,
    /// The address executing the multisig action
    pub outer_signer: String,
    /// The inner action to execute
    pub action: Box<Action>,
}

impl MultiSigPayload {
    /// Computes the prehash for this multisig payload.
    ///
    /// Uses EIP-712 typed data for transfers or RMP+Agent for orders/cancels.
    pub fn prehash(&self, nonce: u64, chain: Chain) -> anyhow::Result<B256> {
        let multi_sig_user: Address = self.multi_sig_user.parse()?;
        let lead: Address = self.outer_signer.parse()?;

        // Determine signing method based on action type
        if let Some(typed_data) = self.action.typed_data_multisig(multi_sig_user, lead, chain) {
            // EIP-712 typed data actions (UsdSend, SpotSend, SendAsset, ConvertToMultiSigUser)
            Ok(typed_data.eip712_signing_hash()?)
        } else {
            // RMP-based actions (orders, cancels, modifications)
            let connection_id = utils::rmp_hash(
                &(&self.multi_sig_user, &self.outer_signer, &self.action),
                nonce,
                None,
                None,
            )?;
            Ok(crate::hypercore::signing::agent_signing_hash(
                chain,
                connection_id,
            ))
        }
    }

    /// Signs this multisig payload synchronously and returns a signature.
    ///
    /// Uses EIP-712 typed data for transfers or RMP+Agent for orders/cancels.
    pub fn sign_sync<S: SignerSync>(
        &self,
        signer: &S,
        nonce: u64,
        chain: Chain,
    ) -> anyhow::Result<Signature> {
        let multi_sig_user: Address = self.multi_sig_user.parse()?;
        let lead: Address = self.outer_signer.parse()?;

        // Determine signing method based on action type
        if let Some(typed_data) = self.action.typed_data_multisig(multi_sig_user, lead, chain) {
            // EIP-712 typed data actions (UsdSend, SpotSend, SendAsset, ConvertToMultiSigUser)
            Ok(signer.sign_dynamic_typed_data_sync(&typed_data)?.into())
        } else {
            // RMP-based actions (orders, cancels, modifications)
            let connection_id = utils::rmp_hash(
                &(&self.multi_sig_user, &self.outer_signer, &self.action),
                nonce,
                None,
                None,
            )?;
            let agent = solidity::Agent {
                source: if chain.is_mainnet() { "a" } else { "b" }.to_string(),
                connectionId: connection_id,
            };
            Ok(signer
                .sign_typed_data_sync(&agent, &CORE_MAINNET_EIP712_DOMAIN)?
                .into())
        }
    }

    /// Signs this multisig payload asynchronously and returns a signature.
    ///
    /// Uses EIP-712 typed data for transfers or RMP+Agent for orders/cancels.
    pub async fn sign<S: Signer + Send + Sync>(
        &self,
        signer: &S,
        nonce: u64,
        chain: Chain,
    ) -> anyhow::Result<Signature> {
        let multi_sig_user: Address = self.multi_sig_user.parse()?;
        let lead: Address = self.outer_signer.parse()?;

        // Determine signing method based on action type
        if let Some(typed_data) = self.action.typed_data_multisig(multi_sig_user, lead, chain) {
            // EIP-712 typed data actions (UsdSend, SpotSend, SendAsset, ConvertToMultiSigUser)
            Ok(signer.sign_dynamic_typed_data(&typed_data).await?.into())
        } else {
            // RMP-based actions (orders, cancels, modifications)
            let connection_id = utils::rmp_hash(
                &(&self.multi_sig_user, &self.outer_signer, &self.action),
                nonce,
                None,
                None,
            )?;
            let agent = solidity::Agent {
                source: if chain.is_mainnet() { "a" } else { "b" }.to_string(),
                connectionId: connection_id,
            };
            Ok(signer
                .sign_typed_data(&agent, &CORE_MAINNET_EIP712_DOMAIN)
                .await?
                .into())
        }
    }

    /// Recovers the signer's address from a multisig action signature.
    ///
    /// Uses EIP-712 typed data for transfers or RMP+Agent for orders/cancels.
    pub fn recover(
        &self,
        signature: &Signature,
        nonce: u64,
        chain: Chain,
    ) -> anyhow::Result<Address> {
        let multi_sig_user: Address = self.multi_sig_user.parse()?;
        let lead: Address = self.outer_signer.parse()?;

        let recid = RecoveryId::from_byte(signature.v as u8 - 27_u8)
            .ok_or_else(|| anyhow::anyhow!("unable to convert recovery_id: {}", signature.v))?;
        let sig = alloy::signers::Signature::new(signature.r, signature.s, recid.is_y_odd());

        // Determine signing method based on action type
        let prehash = if let Some(typed_data) =
            self.action.typed_data_multisig(multi_sig_user, lead, chain)
        {
            // EIP-712 typed data actions (UsdSend, SpotSend, SendAsset, ConvertToMultiSigUser)
            typed_data.eip712_signing_hash()?
        } else {
            // RMP-based actions (orders, cancels, modifications)
            let connection_id = utils::rmp_hash(
                &(&self.multi_sig_user, &self.outer_signer, &self.action),
                nonce,
                None,
                None,
            )?;
            crate::hypercore::signing::agent_signing_hash(chain, connection_id)
        };

        Ok(sig.recover_address_from_prehash(&prehash)?)
    }
}

/// Multi-signature action wrapper.
///
/// Wraps any action with multiple signatures for multisig execution.
#[derive(Clone, Serialize, Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct MultiSigAction {
    /// Signature chain ID (0x66eee for L1 multisig)
    pub signature_chain_id: String,
    /// Signatures from authorized signers
    pub signatures: Vec<Signature>,
    /// The multisig payload
    pub payload: MultiSigPayload,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_deser() {
        let text =
            r#"{"status":"ok","response":{"type":"cancel","data":{"statuses":["success"]}}}"#;
        let data: Response = serde_json::from_str(text).unwrap();
    }
}
